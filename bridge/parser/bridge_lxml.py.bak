#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os.path
import re
try:
    from cStringIO import StringIO as StringIO
except ImportError:
    from StringIO import StringIO

from lxml import etree
from lxml import objectify
from lxml.objectify import fromstring, StringElement, ObjectifiedElement

_parser = etree.XMLParser()
_lookup = objectify.ObjectifyElementClassLookup()
_parser.setElementClassLookup(_lookup)
_lookup = etree.ElementNamespaceClassLookup(objectify.ObjectifyElementClassLookup())
_parser.setElementClassLookup(_lookup)

from bridge import Attribute, Element
from bridge import ENCODING, DUMMY_URI, __version__

_qcrx = re.compile('{(.*)}(.*)')

def _ln(elt):
    if elt.prefix:
        return unicode(elt.tag[len('{%s}' % elt.nsmap[elt.prefix]):])
    return unicode(elt.tag)

def _split_qcname(qcname):
    m = _qcrx.match(qcname)
    if m and len(m.groups()) == 2:
        return unicode(m.group(1)), unicode(m.group(2))
    return None, unicode(qcname)

def _get_prefix(elt, ns):
    for _ in elt.nsmap:
        if elt.nsmap[_] == ns:
            return unicode(_)
    return None

def _ns(elt):
    if elt.prefix:
        return unicode(elt.nsmap[elt.prefix])
    return None

class Parser(object):
    def __deserialize_fragment(self, current, parent):
        for child in current.iterchildren():
            content = value = tail = None
            if type(child) != ObjectifiedElement:
                content = child.text
                if content:
                    content = unicode(content)

            element = Element(name=_ln(child), content=content,
                              prefix=child.prefix, namespace=_ns(child),
                              parent=parent)
            
            for attr_key in child.attrib:
                ns, local_name = _split_qcname(attr_key)
                prefix = _get_prefix(child, ns)
                value = unicode(child.attrib[attr_key])
                Attribute(name=local_name, value=value,
                          prefix=prefix, namespace=ns, parent=element)
                
            if type(child) == ObjectifiedElement:
                children = child.getchildren()
                content = child.text
                if content:
                    element.xml_children.append(unicode(content))
                self.__deserialize_fragment(child, element)
                if children:
                    tail = children[-1].tail
                    if tail:
                        element.xml_children.append(unicode(tail))

    def __qname(self, name, ns=None):
        if ns:
            return "{%s}%s" % (ns, name)
        return name

    def __serialize_attribute(self, node, attr):
        name = attr.name.encode()
        if attr.prefix and attr.xmlns:
            ns = attr.xmlns.encode()
            prefix = attr.prefix.encode()
            
            if prefix not in node.nsmap:
                node.nsmap[prefix] = ns
            node.set('{%s}%s' % (ns, name), str(attr))
        else:
            node.set(name, str(attr.xml_text))

    def __serialize_element(self, node, element, tail=None):
        for attr in element.xml_attributes:
            self.__serialize_attribute(node, attr)

        if tail:
            node.tail = tail

        children = element.xml_children
        print "## %s" % node.tag
        print children
        children_num = len(children)
        for child in children:
            index = children.index(child)
            print index
            if isinstance(child, basestring):
                if children[0] == child:
                    ns, ln = _split_qcname(node.tag)
                    parent = node.getparent()
                    if not parent:
                        parent = node
                    print "### %s %s" % (parent.tag, ln)
                    setattr(parent, ln, child.encode(element.encoding))
            elif isinstance(child, Element):
                prefix = ns = name = None
                if child.prefix:
                    prefix = child.prefix.encode(child.encoding)
                if child.xmlns:
                    ns = child.xmlns.encode(child.encoding)
                if prefix not in node.nsmap:
                    node.nsmap[prefix] = ns
                
                name = child.name.encode(child.encoding)
                name = self.__qname(name, ns=ns)
            
                child_node = etree.SubElement(node, name)
                print "# %s" % child_node.tag
                if child.xml_text:
                    setattr(node, name, str(child))
                node.append(child_node)

                if index == (children_num - 2):
                    if isinstance(children[-1], basestring):
                        tail = children[-1]
                        child_node.tail = tail.encode(child.encoding)
                
                self.__serialize_element(child_node, child, tail)

    def __serialize_root_element(self, root, content=None):
        content = content or ''
        if content:
            content = str(content)
        if root.prefix:
            return '<%s:%s xmlns:%s="%s">%s</%s:%s>' % (root.prefix, root.name,
                                                        root.prefix, root.xmlns,
                                                        content, root.prefix, root.xmlns)
        return '<%s>%s</%s>' % (root.name, content, root.name)

    def serialize(self, document, indent=True, encoding=ENCODING, prefixes=None):
        prefixes = prefixes or {}
        t = self.__serialize_root_element(document, content=document.xml_text)
        doc = fromstring(t.encode(encoding))
        print dir(doc)
        self.__serialize_element(doc, document)

        return etree.tostring(doc, pretty_print=indent, encoding=encoding)

    def deserialize(self, source, prefixes=None, strict=False):
        autoclose = False
        if isinstance(source, basestring):
            autoclose = True
            if os.path.exists(source):
                source = file(source, 'rb')
            else:
                source = StringIO(source)

        doc = etree.parse(source, _parser)
        
        if autoclose:
            source.close()

        root = doc.getroot()
        content = None
        children = root.getchildren()
        if root.text:
            if children:
                content = unicode(root.text)
                
        element = Element(name=_ln(root), prefix=root.prefix,
                          namespace=_ns(root), content=content)
        if root.text:
            if children:
                element.xml_children.append(unicode(root.text))
            
        self.__deserialize_fragment(root, element)
        
        return element

